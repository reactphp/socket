<?php

namespace React\Tests\Socket;

use React\EventLoop\Factory;
use React\EventLoop\LoopInterface;
use React\Socket\ConnectionInterface;
use React\Socket\Connector;
use React\Socket\TcpServer;

function _log ($message) {
    echo $message . "\n";
};

/**
 * Class AllowHalfOpenTest
 * Inspired by https://github.com/nodejs/node/blob/01c680b92aed62e128aa2abd4ad923f9a6a0331a/test/parallel/test-net-connect-options-allowhalfopen.js
 * Run with `php vendor/bin/phpunit --filter AllowHalfOpenTest`
 *
 * @package React\Tests\Socket
 */
class AllowHalfOpenTest extends TestCase
{
    /**
     * @var LoopInterface
     */
    private $loop;
    private $server;
    /**
     * @var TcpServer
     */
    private $socket;
    private $options = ['allowHalfOpen' => true];

    private $clientReceivedFIN = 0;
    private $serverConnections = 0;
    private $clientSentFIN = 0;
    private $serverReceivedFIN = 0;

    private function createLoop()
    {
        return Factory::create();
    }

    /**
     * @covers React\Socket\TcpServer::__construct
     * @covers React\Socket\TcpServer::getAddress
     */
    public function setUp()
    {
        $this->loop = $this->createLoop();
        $this->socket = new TcpServer(0, $this->loop, $this->options);
    }

    /**
     * @covers React\Socket\TcpServer::handleConnection
     */
    public function testAll()
    {
        $this->socket->on('connection', [$this, 'serverOnConnection']);
        $client = new Connector($this->loop, $this->options);
        $client->connect($this->socket->getAddress())
            ->then($this->clientOnConnect(1))
            ->otherwise(function ($error) { _log($error); });

        $this->loop->run();
    }

    private function clientOnConnect($index)
    {
        $clientReceivedFIN = $this->clientReceivedFIN;
        $clientSentFIN = $this->clientSentFIN;
        return function (ConnectionInterface $connection) use ($index, &$clientReceivedFIN, &$clientSentFIN) {
            $client = $connection;
            _log("'connect' emitted on Client {$index}");

            $client->resume();
            $client->on('end', function () use ($index, $client, &$clientSentFIN) {
                _log("Client on end");
                $this->loop->addTimer(0.05, function () use ($index, $client, &$clientSentFIN) {
                    // when allowHalfOpen is true, client must still be writable
                    // after the server closes the connections, but not readable
                    _log("client {$index} received FIN");
                    _log("!client.readable: " . var_export(!$client->isReadable(), 1));
                    _log("client.writable: " . var_export($client->isWritable(),1));

                    $writeResult = $client->write($index);
                    _log("writeResult " . var_export($writeResult,1));

                    $client->end();

                    $clientSentFIN++;
                    _log("client {$index} sent FIN, {$clientSentFIN} have been sent");
                });
            });
            $client->on('close', function () use ($index, &$clientReceivedFIN) {
                $clientReceivedFIN++;
                _log("connection {$index} has been closed by both sides," .
                    " {$clientReceivedFIN} clients have closed");
            });
        };
    }

    public function serverOnConnection(ConnectionInterface $conn)/* use (&$socket, &$serverReceivedFIN, &$serverConnections, $clientReceivedFIN, $clientSentFIN, $serverConnections) */
    {
        $this->serverConnections++;
        _log("'connection' {$this->serverConnections} emitted on server");
        $srvConn = $this->serverConnections;
        /**
         * @var $socket TcpServer
         */
        $socket = $this->socket;

        //    $conn->resume();
        $conn->on('data', function ($data) use ($srvConn, &$conn) {
            _log("Recieved data: " . $data);
            $conn->clientId = $data . '';
            _log("server connection {$srvConn} is started by client {$conn->clientId}");
        });
        // 'end' on each socket must not be emitted twice
        $conn->on('end', function () use (&$conn, $socket) {
            _log("Server received FIN sent by client {$conn->clientId}");
            $this->loop->addTimer(0.05, function () use (&$socket) {
                /**
                 * @var $socket \React\Socket\ServerInterface
                 */
                $socket->close();
            });
        });

        $conn->end();
    }

    /**
     * @covers React\Socket\TcpServer::close
     */
    public function tearDown()
    {
        if ($this->server) {
            $this->server->close();
        }
    }
}
